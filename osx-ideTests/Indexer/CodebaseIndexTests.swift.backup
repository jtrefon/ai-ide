//
//  CodebaseIndexTests.swift
//  osx-ideTests
//
//  Created by Cascade on 24/12/2025.
//

import XCTest
@testable import osx_ide
import Combine

final class CodebaseIndexTests: XCTestCase {
    var codebaseIndex: CodebaseIndex!
    var tempDir: URL!
    var mockEventBus: MockEventBus!
    var mockAIService: CodebaseIndexMockAIService!
    var dbManager: DatabaseManager!

    override func setUp() async throws {
        try await super.setUp()
        tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        let tempDBPath = tempDir.appendingPathComponent(UUID().uuidString + ".sqlite").path
        dbManager = try DatabaseManager(path: tempDBPath)
        await MainActor.run {
            mockEventBus = MockEventBus()
            mockAIService = CodebaseIndexMockAIService()
        }
        codebaseIndex = try await MainActor.run {
            try CodebaseIndex(eventBus: mockEventBus, projectRoot: tempDir, aiService: mockAIService)
        }
    }

    override func tearDown() async throws {
        codebaseIndex = nil
        dbManager = nil
        try? FileManager.default.removeItem(at: tempDir)
        try await super.tearDown()
    }

    func createTestFile(at relativePath: String, content: String = "test") throws {
        let url = tempDir.appendingPathComponent(relativePath)
        let dir = url.deletingLastPathComponent()
        try FileManager.default.createDirectory(at: dir, withIntermediateDirectories: true)
        try content.write(to: url, atomically: true, encoding: .utf8)
    }

    func testListIndexedFiles_empty() async throws {
        let results = try await codebaseIndex.listIndexedFiles(matching: nil, limit: 10, offset: 0)
        XCTAssertTrue(results.isEmpty)
    }

    func testListIndexedFiles_withFiles() async throws {
        try createTestFile(at: "src/main.swift")
        try createTestFile(at: "README.md")
        try createTestFile(at: "src/utils/helpers.swift")

        // Trigger indexing
        await MainActor.run {
            codebaseIndex.reindexProject()
        }

        // Allow async indexing to complete (simplified for test)
        let expectation = XCTestExpectation(description: "Indexing completes")
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            expectation.fulfill()
        }
        await fulfillment(of: [expectation], timeout: 2.0)

        let results = try await codebaseIndex.listIndexedFiles(matching: nil, limit: 10, offset: 0)
        XCTAssertGreaterThanOrEqual(results.count, 3)
        XCTAssertTrue(results.contains { $0.hasSuffix("src/main.swift") })
        XCTAssertTrue(results.contains { $0.hasSuffix("README.md") })
    }

    func testListIndexedFiles_withFilter() async throws {
        try createTestFile(at: "src/main.swift")
        try createTestFile(at: "src/utils/helpers.swift")
        try createTestFile(at: "README.md")

        await MainActor.run {
            codebaseIndex.reindexProject()
        }

        let expectation = XCTestExpectation(description: "Indexing completes")
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            expectation.fulfill()
        }
        await fulfillment(of: [expectation], timeout: 2.0)

        let results = try await codebaseIndex.listIndexedFiles(matching: "src", limit: 10, offset: 0)
        XCTAssertTrue(results.allSatisfy { $0.contains("src") })
        XCTAssertFalse(results.contains { $0.contains("README") })
    }

    func testFindIndexedFiles_ranking() async throws {
        try createTestFile(at: "train_cli.py")
        try createTestFile(at: "src/train_cli.py")
        try createTestFile(at: "docs/train_cli.md")
        try createTestFile(at: "README.md")

        await MainActor.run {
            codebaseIndex.reindexProject()
        }

        let expectation = XCTestExpectation(description: "Indexing completes")
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            expectation.fulfill()
        }
        await fulfillment(of: [expectation], timeout: 2.0)

        let matches = try await codebaseIndex.findIndexedFiles(query: "train_cli", limit: 10)
        XCTAssertGreaterThanOrEqual(matches.count, 3)

        // Basename exact match should be first
        let first = matches.first!
        XCTAssertTrue(first.path.contains("train_cli.py"))
        XCTAssertFalse(first.path.hasSuffix(".md")) // docs penalty
    }

    func testReadIndexedFile_withLineNumbers() async throws {
        let content = """
        line 1
        line 2
        line 3
        line 4
        """
        try createTestFile(at: "test.txt", content: content)

        await MainActor.run {
            codebaseIndex.reindexProject()
        }

        let expectation = XCTestExpectation(description: "Indexing completes")
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            expectation.fulfill()
        }
        await fulfillment(of: [expectation], timeout: 2.0)

        let result = try await codebaseIndex.readIndexedFile(path: "test.txt", startLine: nil, endLine: nil)
        let lines = result.components(separatedBy: .newlines)
        XCTAssertTrue(lines[0].contains("1 | line 1"))
        XCTAssertTrue(lines[1].contains("2 | line 2"))
    }

    func testReadIndexedFile_withRange() async throws {
        let content = "line 1\nline 2\nline 3\nline 4\nline 5"
        try createTestFile(at: "test.txt", content: content)

        await MainActor.run {
            codebaseIndex.reindexProject()
        }

        let expectation = XCTestExpectation(description: "Indexing completes")
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            expectation.fulfill()
        }
        await fulfillment(of: [expectation], timeout: 2.0)

        let result = try await codebaseIndex.readIndexedFile(path: "test.txt", startLine: 2, endLine: 4)
        let lines = result.components(separatedBy: .newlines)
        XCTAssertEqual(lines.count, 3)
        XCTAssertTrue(lines[0].contains("2 | line 2"))
        XCTAssertTrue(lines[1].contains("3 | line 3"))
        XCTAssertTrue(lines[2].contains("4 | line 4"))
    }

    func testUpdateQualityScore() throws {
        let id = UUID().uuidString
        let path = "src/main.swift"
        let insertSql = """
        INSERT INTO resources (id, path, language, last_modified, content_hash, quality_score)
        VALUES ('\(id)', '\(path)', 'swift', 0.0, 'hash', 7.5);
        """
        try dbManager.execute(sql: insertSql)

        try dbManager.updateQualityScore(resourceId: id, score: 8.8)

        // Simple verification - just check that update doesn't throw
        XCTAssertTrue(true)
    }

    func testSearchIndexedText() async throws {
        try createTestFile(at: "src/main.swift", content: "func hello() { print(\"hello\") }")
        try createTestFile(at: "README.md", content: "# Project\n")

        await MainActor.run {
            codebaseIndex.reindexProject()
        }

        let expectation = XCTestExpectation(description: "Indexing completes")
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            expectation.fulfill()
        }
        await fulfillment(of: [expectation], timeout: 2.0)

        let matches = try await codebaseIndex.searchIndexedText(pattern: "hello", limit: 10)
        XCTAssertGreaterThanOrEqual(matches.count, 1)
        XCTAssertTrue(matches.first!.contains("src/main.swift"))
        XCTAssertTrue(matches.first!.contains(":1:"))
    }

    func testSearchSymbols() async throws {
        let swiftCode = """
        class MyClass {
            func myFunction() {
                let myVar = 42
            }
        }
        """
        try createTestFile(at: "test.swift", content: swiftCode)

        await MainActor.run {
            codebaseIndex.reindexProject()
        }

        let expectation = XCTestExpectation(description: "Indexing completes")
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            expectation.fulfill()
        }
        await fulfillment(of: [expectation], timeout: 3.0)

        let symbols = try await codebaseIndex.searchSymbols(nameLike: "my", limit: 10)
        XCTAssertGreaterThanOrEqual(symbols.count, 2)
        XCTAssertTrue(symbols.map { $0.name }.contains("MyClass"))
        XCTAssertTrue(symbols.map { $0.name }.contains("myFunction"))
    }

    func testMarkAIEnriched() throws {
        let id = UUID().uuidString
        let path = "src/main.swift"
        let insertSql = """
        INSERT INTO resources (id, path, language, last_modified, content_hash, quality_score)
        VALUES ('\(id)', '\(path)', 'swift', 0.0, 'hash', 7.5);
        """
        try dbManager.execute(sql: insertSql)

        try dbManager.markAIEnriched(resourceId: id, score: 9.1)

        // Simple verification - just check that marking doesn't throw
        XCTAssertTrue(true)
    }
}

// MARK: - Mocks

class MockEventBus: EventBusProtocol {
    private var subscriptions: [String: Any] = [:]

    func publish<E>(_ event: E) where E : Event {
        // No-op for tests
    }

    func subscribe<E>(to eventType: E.Type, handler: @escaping (E) -> Void) -> AnyCancellable where E : Event {
        let id = UUID().uuidString
        subscriptions[id] = handler
        return AnyCancellable {
            self.subscriptions.removeValue(forKey: id)
        }
    }
}

@unchecked Sendable class CodebaseIndexMockAIService: AIService {
        AIServiceResponse(content: "Mock response", toolCalls: nil)
    }

    func sendMessage(_ message: String, context: String?, tools: [AITool]?, mode: AIMode?, projectRoot: URL?) async throws -> AIServiceResponse {
        AIServiceResponse(content: "Mock response", toolCalls: nil)
    }

    func sendMessage(_ messages: [ChatMessage], context: String?, tools: [AITool]?, mode: AIMode?, projectRoot: URL?) async throws -> AIServiceResponse {
        AIServiceResponse(content: "Mock response", toolCalls: nil)
    }

    func explainCode(_ code: String) async throws -> String {
        "Mock explanation"
    }

    func refactorCode(_ code: String, instructions: String) async throws -> String {
        "Mock refactor"
    }

    func generateCode(_ prompt: String) async throws -> String {
        "Mock code"
    }

    func fixCode(_ code: String, error: String) async throws -> String {
        "Mock fix"
    }
}
